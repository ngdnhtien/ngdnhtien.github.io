<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Quantum computation with bosonic qubits - Haar&#39;s Half Measure</title>

	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta itemprop="name" content="Quantum computation with bosonic qubits">
<meta itemprop="description" content="My take on quantum computing with harmonic oscillators."><meta itemprop="datePublished" content="2023-07-27T00:00:00+00:00" />
<meta itemprop="dateModified" content="2023-07-27T00:00:00+00:00" />
<meta itemprop="wordCount" content="4407">
<meta itemprop="keywords" content="quant-ph,quantum-error-correction," /><meta property="og:title" content="Quantum computation with bosonic qubits" />
<meta property="og:description" content="My take on quantum computing with harmonic oscillators." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ngdnhtien.github.io/2023/07/quantum-computation-with-bosonic-qubits/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-27T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-07-27T00:00:00+00:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Quantum computation with bosonic qubits"/>
<meta name="twitter:description" content="My take on quantum computing with harmonic oscillators."/>
<link rel="stylesheet" type="text/css" media="screen" href="https://ngdnhtien.github.io/css/normalize.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="https://ngdnhtien.github.io/css/main.css" />

        <link id="dark-scheme" rel="stylesheet" type="text/css" href="https://ngdnhtien.github.io/css/dark.css" />

	<script src="https://ngdnhtien.github.io/js/feather.min.js"></script>
	
		<script src="https://ngdnhtien.github.io/js/main.js"></script>
</head>

<body>
	<div class="container wrapper">
		
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css" integrity="sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js" integrity="sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          
          
          delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
              {left: '\\(', right: '\\)', display: false},
              {left: '\\[', right: '\\]', display: true}
          ],
          
          throwOnError : false
        });
    });
</script>

<div class="header">
	
	<h1 class="site-title"><a href="https://ngdnhtien.github.io/">Haar&#39;s Half Measure</a></h1>
	<div class="site-description"><p>What I talk about when I talk about physics.</p><nav class="nav social">
			<ul class="flat"><li><a href="https://github.com/ngdnhtien" title="Github"><i data-feather="github"></i></a></li><li><a href="https://twitter.com/ngdnhtien" title="Twitter"><i data-feather="twitter"></i></a></li><span class="scheme-toggle"><a href="#" id="scheme-toggle"></a></ul>
		</nav>
	</div>

	<nav class="nav">
		<ul class="flat">
			
			<li>
				<a href="/">Home</a>
			</li>
			
			<li>
				<a href="/posts">All posts</a>
			</li>
			
			<li>
				<a href="/tags">Tags</a>
			</li>
			
		</ul>
	</nav>
</div>

		<div class="post">
			<div class="post-header">
				
					<div class="meta">
						<div class="date">
							<span class="day">27</span>
							<span class="rest">Jul 2023</span>
						</div>
					</div>
				
				<div class="matter">
					<h1 class="title">Quantum computation with bosonic qubits</h1>
				</div>
			</div>

			
			
			<aside class="toc">
				<header>
				<h2>Contents</h2>
				</header>
				<nav id="TableOfContents">
  <ol>
    <li><a href="#baby-quantum-optics">Baby quantum optics</a>
      <ol>
        <li><a href="#freshen-your-mind">Freshen your mind</a></li>
        <li><a href="#coherent-states">Coherent states</a>
          <ol>
            <li><a href="#properties-of-coherent-states">Properties of coherent states</a></li>
            <li><a href="#phase-shifting-operator">Phase shifting operator</a></li>
            <li><a href="#displacement-operator">Displacement operator</a>
              <ol>
                <li><a href="#generation-of-coherent-states-using-displacement-operator">Generation of coherent states using displacement operator</a></li>
              </ol>
            </li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#bosonic-codes">Bosonic codes</a>
      <ol>
        <li><a href="#bosonic-rotation-codes">Bosonic rotation codes</a>
          <ol>
            <li><a href="#preliminaries">Preliminaries</a></li>
            <li><a href="#fock-space-structure">Fock-space structure</a></li>
            <li><a href="#the-phase-grids-and-the-fock-grids">The phase grids and the Fock grids</a></li>
            <li><a href="#distinguishing-the-code-words">Distinguishing the code words</a></li>
          </ol>
        </li>
        <li><a href="#number-phase-codes">Number-phase codes</a>
          <ol>
            <li><a href="#ideal-number-phase-codes">Ideal number-phase codes</a></li>
            <li><a href="#approximate-number-phase-codes">Approximate number-phase codes</a></li>
            <li><a href="#symmetry-as-a-resource-quantum-computing-with-number-phase-codes">Symmetry as a resource: quantum computing with number-phase codes</a></li>
            <li><a href="#universal-operations-for-number-phase-codes">Universal operations for number-phase codes</a>
              <ol>
                <li><a href="#unitary-gates">Unitary gates</a></li>
                <li><a href="#teleported-gates">Teleported gates</a></li>
              </ol>
            </li>
          </ol>
        </li>
      </ol>
    </li>
  </ol>
</nav>
			</aside>
			
					
			<div class="markdown">
				<h1 id="baby-quantum-optics">Baby quantum optics</h1>
<p>So instead of playing with spin-$1/2$ particles as usual in superconducting qubits, we&rsquo;re dealing with photons. It&rsquo;s good to review some really basic stuff.</p>
<h2 id="freshen-your-mind">Freshen your mind</h2>
<p>In this very first section let us review basic ingredients of quantum mechanics 1, specifically the quantum harmonic oscillator and its coherent states.</p>
<p>The harmonic oscillator problem can be formulation in the matrix representation, associating with the concepts of Fock space and occupation number. Let us start from the eigenfunctions of the harmonic oscillator $\psi_n(x)$, which form a complete orthonormal basis for the corresponding Hilbert space. The following vectors</p>
<p>\[
\begin{align}
\psi_0 \to \begin{bmatrix} 1 \newline 0 \newline 0 \newline \vdots\end{bmatrix} \equiv |0\rangle, \quad
\psi_1\to \begin{bmatrix} 0 \newline 1 \newline 0 \newline \vdots\end{bmatrix} \equiv |1\rangle, \quad
\psi_n \to\begin{bmatrix}0 \newline \vdots \newline n \newline \vdots\end{bmatrix} \equiv |n\rangle.
\end{align}
\]</p>
<p>are the column vector representation of the eigenfunctions $\psi_i$. These vectors are, by construction orthonormal $\langle n|m\rangle = \delta_{nm}$, and form the so called <em>Fock space</em> or <em>occupation number space</em></p>
<p>The state labelled $n$ can be constructed from the ground state by repeatedly adding quantization of energy by the ladder operator,</p>
<p>\[
\begin{align}
|n\rangle = \dfrac{1}{\sqrt{n!}}(a^\dagger)^n |0\rangle
\end{align}
\]</p>
<p>Since $\{|n\rangle\}$ form a complete orthonormal basis, we can get the matrix representation for any operator. For example, the Hamiltonian written in the Fock state basis is</p>
<p>\[
\begin{align}
\langle m | {H} | n \rangle &amp;= \hbar\omega(n+0.5)\langle m |n\rangle\
&amp;= \hbar\omega \begin{bmatrix}1/2 &amp; 0 &amp; 0 &amp; \dots \newline
0 &amp; 3/2 &amp; 0 &amp; \dots \newline
0 &amp; 0 &amp; 5/2 &amp; \dots \newline
\vdots &amp; \dots &amp; \dots &amp; \ddots \end{bmatrix}
\end{align}
\]</p>
<h2 id="coherent-states">Coherent states</h2>
<p>Coherent states play a pivotal role in quantum optics. The operator we&rsquo;re about to derive is named after Roy J. Glauber, Nobel prize laureate to the quantum theory of optical coherence.</p>
<p>Imagining a laser. How many photons does a laser beam have? It seems indefinitely many. But what makes laser such a breakthrough at the time of its invention is that although we have a massive amount of photons, they all pick up a precisely defined phase. A white light, on the other hand, is a statistical mixture of many many photons with random phases and oscillating orientations.</p>
<blockquote>
<p>Definition: A <strong>coherent state</strong> $|\alpha\rangle$, or a Glauber state, is defined as eigenstate of the annihilation operator ${a}$ with eigenvalues $\alpha\in\mathbb{C}$, i.e. ${a}|\alpha\rangle = \alpha|\alpha\rangle$.</p>
</blockquote>
<p>Notice that ${a}$ is a non-hermitian operator<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>, hence the phase $\alpha$ is complex-valued, with a certain amplitude $|\alpha|$ and a phase $\alpha=|\alpha|e^{i\varphi}$.</p>
<h3 id="properties-of-coherent-states">Properties of coherent states</h3>
<p>First, let us calculate the expectation value of energy in a certain coherent state $|\alpha\rangle$.</p>
<p>\[
\langle {H} \rangle = \langle \alpha|{H}|\alpha\rangle = \hbar\omega\langle \alpha|{n}+\dfrac{1}{2}|\alpha\rangle = \hbar\omega(|\alpha|^2+\dfrac{1}{2})
\]</p>
<h3 id="phase-shifting-operator">Phase shifting operator</h3>
<p>Now we introduce the <em>phase shifting operator</em>,</p>
<p>\[
\begin{align}
U(\theta)=\exp{\left(-i\theta{n}\right)}
\end{align}
\]</p>
<p>where ${n}$ is the occupation number operator. It&rsquo;s worth noting that</p>
<p>\[
\begin{align}
U^\dagger(\theta){a}U(\theta)= ae^{-i\theta}
\end{align}
\]</p>
<p>To prove this, take the differentation w.r.t to $\theta$ on the left hand side,</p>
<p>\[
\begin{align}
d/d\theta\left(U^\dagger{a}U\right)&amp;= d/d\theta\left(e^{i\theta n}ae^{-i\theta n }\right)\newline
&amp;= i U^\dagger na U - iU^\dagger a nU\newline
&amp;=iU^\dagger[n, a]U\newline
&amp;=iU^\dagger(a^\dagger a a - aa^\dagger a)U\newline
&amp;=iU^\dagger([a^\dagger, a]a)U\newline
&amp;=-iU^\dagger a U
\end{align}
\]</p>
<p>Hence,</p>
<p>\[
\begin{align}
\int\dfrac{d(U^\dagger a U)}{U^\dagger a U} = \int-id\theta\newline
\ln(U^\dagger a U) = -i\theta + C\newline
U^\dagger a U = A(0)e^{-i\theta}
\end{align}
\]</p>
<p>The constant of integral is found by letting $\theta=0$, and one finds that $U^\dagger(0)aU(0)=a$, hence $A(0)=a$. $\Box$</p>
<p>The phase shifting $U(\theta)$ does two things: (1) it gives the amplitude operator (or annihilation operator) a phase shift $\theta$; and (2) it shifts the phase of a coherent state, i.e. rotating the coherence state by an angle $\theta$ in the phase space $(q, p)$. The latter can be seen by considering</p>
<p>\[
\begin{align}
Ua|\alpha\rangle &amp;= \alpha U|\alpha\rangle\newline
U a U^\dagger U|\alpha\rangle &amp;= \alpha U|\alpha\rangle\newline
ae^{i\theta}U|\alpha\rangle &amp;= \alpha U|\alpha\rangle\newline
a |\alpha&rsquo;\rangle &amp;= \alpha e^{-i\theta}|\alpha&rsquo;\rangle
\end{align}
\]</p>
<p>which from the definition of the coherent state, $a|\alpha&rsquo;\rangle=\alpha&rsquo;|\alpha&rsquo;\rangle$, implying that $\alpha&rsquo;=\alpha e^{-i\theta}$. $\Box$</p>
<p>In conclusion,</p>
<p>\[
U(\theta)|\alpha\rangle = |\alpha e^{-i\theta}\rangle
\]</p>
<h3 id="displacement-operator">Displacement operator</h3>
<p>Another type of important operator is the displacement operator</p>
<p>\[
\begin{align}
D(\alpha) = \exp\left(\alpha a^\dagger - \alpha^* a\right)
\end{align}
\]</p>
<p>where $\alpha=|\alpha|e^{i\varphi}$ is a complex number and $a (a^\dagger)$ are ladder operators. One can verify that the displacement operator is unitary. But first, let us re-write the displacement operator in another form. Using a special case of the Baker–Campbell–Hausdorff formula, for any $A$ and $B$ that commutes with $[A, B]$, we have</p>
<p>\[
\begin{align}
\exp(A+B) = \exp (A) \exp (B) \exp\left(-\dfrac{1}{2}[A, B]\right)
\end{align}
\]</p>
<p>Since $[a,a^\dagger]=1$, $[a,[a,a^\dagger]]=[a^\dagger,[a,a^\dagger]]=0$. Hence we can write</p>
<p>\[
\begin{align}
D(\alpha) &amp;= \exp(\alpha a^\dagger)\exp(-\alpha^* a)\exp\left(-\dfrac{1}{2}[\alpha a^\dagger, - \alpha^* a]\right)\newline
&amp;= \exp(\alpha a^\dagger) \exp(-\alpha^*a)\exp(-{|\alpha|^2}/{2})\newline
&amp;= \exp(-{|\alpha|^2}/{2})\exp(\alpha a^\dagger) \exp(-\alpha^*a)
\end{align}
\]</p>
<p>Now the adjoint $D^\dagger(\alpha)$,</p>
<p>\[
\begin{align}
D^\dagger(\alpha) &amp;= \exp\left(\alpha^* a - \alpha a^\dagger\right)\newline
&amp;= \exp(\alpha^* a)\exp(-\alpha a^\dagger) \exp\left(-\dfrac{1}{2}[\alpha^*a, -\alpha a^\dagger]\right)\newline
&amp;= \exp\left(|\alpha|^2/2\right) \exp(\alpha^{*} a) \exp(-\alpha a^\dagger)
\end{align}
\]</p>
<p>And their product,</p>
<p>\[
\begin{align}
D^\dagger(\alpha)D(\alpha) = \exp\left(|\alpha|^2/2\right) &amp;\exp(\alpha^{*} a) \exp(-\alpha a^\dagger)\newline &amp;\times \exp(-{|\alpha|^2}/{2})\exp(\alpha a^\dagger) \exp(-\alpha^*a)= I
\end{align}
\]</p>
<p>Notice that</p>
<p>\[
\begin{align}
D(-\alpha) &amp;= \exp\left(-\alpha a^\dagger +\alpha^* a\right)\newline
&amp;=\exp\left(\alpha^* a - \alpha a^\dagger\right)\equiv D^\dagger(\alpha)
\end{align}
\]</p>
<p>Some more important properties of the displacement operators</p>
<p>\[
\begin{align}
D^\dagger(\alpha) a D(\alpha) &amp;= \exp\left(\alpha^* a - \alpha a^\dagger\right)a \exp\left(\alpha a^\dagger - \alpha^* a\right) = a +\alpha\newline
D^\dagger(\alpha) a^\dagger D(\alpha) &amp;= \exp\left(\alpha^* a - \alpha a^\dagger\right)a^\dagger \exp \left(\alpha a^\dagger - \alpha^* a\right) = a^\dagger + \alpha^*
\end{align}
\]</p>
<p>These can be proven using the BCH formula again. For example, the operator $D^\dagger a D$ results in</p>
<p>\[
\begin{align}
D^\dagger a D &amp;= a + [(\alpha^* a - \alpha a^\dagger), a] + \dfrac{1}{2!}[\alpha^* a - \alpha a^\dagger, [\alpha^* a - \alpha a^\dagger, a]] + \dots\newline
&amp;= a + \alpha^* [a, a] - \alpha[a^\dagger, a] \newline
&amp;= a + \alpha.\ \Box
\end{align}
\]</p>
<p>Lastly, displacement of a total of $\alpha+\beta$,</p>
<p>\[
\begin{align}
D(\alpha+\beta) &amp;= \exp\left((\alpha+\beta)a^\dagger - (\alpha+\beta)^* a\right)\newline
&amp;= \exp\left(\alpha a^\dagger-\alpha^* a + \beta a^\dagger -\beta^* a\right)\newline
&amp;=\exp\left(\alpha a^\dagger - \alpha^* a\right)\exp\left(\beta a^\dagger - \beta^* a\right)\exp\left(-\dfrac{1}{2}[\alpha a^\dagger - \alpha^* a, \beta a^\dagger - \beta^* a]\right)\newline
&amp;=\exp\left(-\dfrac{1}{2}(\alpha\beta^*-\alpha^*\beta)\right)\exp\left(\alpha a^\dagger - \alpha^* a\right)\exp\left(\beta a^\dagger - \beta^* a\right)\newline
&amp;=\exp\left(-i\text{Im}(\alpha\beta^*)\right)D(\alpha)D(\beta)
\end{align}
\]</p>
<p>Oh by the way let us calculate some commutators, as they will come in handy later,</p>
<p>\[
\begin{align}
[a, D(\alpha)]
&amp;=[a, \exp(|\alpha|^2/2)\exp(\alpha a^\dagger)\exp(-\alpha^* a)]\newline
&amp;=\exp(-|\alpha|^2/2)[a, \exp(\alpha a^\dagger)\exp(-\alpha^* a)]\newline
&amp;=\exp(-|\alpha|^2/2)\left([a, \exp(\alpha a^\dagger)]\exp(-\alpha^* a)+\exp(\alpha a^\dagger)[a, \exp(-\alpha^* a)]\right)
\end{align}
\]</p>
<p>Now apparently $[a, \exp(-\alpha^* a)]=0$. The other one $[a, \exp(\alpha a^\dagger)]$ is a bit more tricky. Here&rsquo;s a result that should help,</p>
<p>\[\begin{align}\begin{cases}
[A, [A,B]]=0\newline
[B, [A,B]]=0\end{cases} \rightarrow [A, f(B)]= [A,B]f&rsquo;(B)
\end{align}
\]</p>
<p>Here we already knew that $[a, [a, a^\dagger]]=[a^\dagger, [a, a^\dagger]]=0$. Hence, the commutator of $a$ with a real function of $a^\dagger$ should be</p>
<p>\[
[a, \exp(\alpha a^\dagger)] = [a, a^\dagger]\alpha \exp(\alpha a^\dagger).
\]</p>
<p>In other words,</p>
<p>\[
\begin{align}
[a, D(\alpha)] &amp;= \alpha\exp(-|\alpha|^2/2)\exp(\alpha a^\dagger)\exp(-\alpha^* a)\newline
&amp;=\alpha \exp(\alpha a^\dagger - \alpha^* a)\equiv \alpha D(\alpha)
\end{align}
\]</p>
<p>By analogy, the commutator $[a^\dagger, D(\alpha)]$ is</p>
<p>\[
\begin{align}
[a^\dagger, D(\alpha)] = \alpha^* D(\alpha)
\end{align}
\]</p>
<p>Now we can make use of these commutators to review some of the results derived above. For example,</p>
<p>\[
[a, D(\alpha)]=\alpha D(\alpha) \leftrightarrow a D(\alpha)  = \alpha D(\alpha) + D(\alpha) a
\]</p>
<p>Hence a unitary transformation $D^\dagger(\alpha) a D(\alpha)$ can be written as</p>
<p>\[\begin{align}
D^\dagger(\alpha) a D(\alpha)&amp;=D^\dagger(\alpha)\left(\alpha D(\alpha) + D(\alpha) a\right)\newline
&amp;=\alpha D^\dagger(\alpha)D(\alpha)+D^\dagger(\alpha)D(\alpha)a\newline
&amp;=\alpha + a
\end{align}\]</p>
<p>This is another way of proving the above results of important properties of displacement operators.</p>
<h4 id="generation-of-coherent-states-using-displacement-operator">Generation of coherent states using displacement operator</h4>
<p>Here&rsquo;s a nice theorem: the coherent state $|\alpha\rangle$ is generated from the vacuum state $|0\rangle$ by the displacement operator $D(\alpha)$.</p>
<p>\[
\begin{align}
|\alpha\rangle = D(\alpha) |0\rangle
\end{align}
\]</p>
<p>How to prove this? We should probably consider the action of $a (D(\alpha)|0\rangle)$. If this turns out to be $\alpha&rsquo;|\alpha&rsquo;\rangle$, where $|\alpha&rsquo;\rangle= D(\alpha)|0\rangle$, then we should have proven it.</p>
<p>\[
\begin{align}
aD(\alpha)|0\rangle &amp;= \left(\alpha D(\alpha) + D(\alpha) a\right)|0\rangle\newline
&amp;= \alpha D(\alpha) |0\rangle + D(\alpha) a |0\rangle\newline
&amp;= \alpha D(\alpha) |0\rangle
\end{align}
\]</p>
<p>meaning that $D(\alpha)|0\rangle$ is indeed an eigenvector of $a$, hence it is must be a coherent state.</p>
<h1 id="bosonic-codes">Bosonic codes</h1>
<p>Encoding quantum information into bosonic systems, i.e. continous-variable (CV) systems is an alternative to conventional error-correting codes based on discrete-variable systems.</p>
<p>There are basically two kinds of bosonic codes at the present, each exploits a different type of symmetry to protect encoded information. The first one, based on discrete translation symmetry in phase space, notably the Gottesman, Kitaev, and Preskill (GKP) code. We won&rsquo;t get into that.</p>
<p>The other one, much heralded experimentally, being codes that are based on discrete rotation symmetry in phase space. Two most notable examples being the cat code and binomial code. In what follows, we try to unify the two codes under one formalism.</p>
<p>Here&rsquo;s several key points before we move further.</p>
<ol>
<li>
<p>Bosonic rotation-symmetric codes are the ones whose logical qubits encoded into a subspace in which the discrete rotation operator $\hat{Z}_N=\exp\left(i\dfrac{\pi}{N}\hat{n}\right)$ acts as logical $\bar{Z}$, where $\hat{n}$ being the Fock-space number operator. Note that this feature of logical $\bar{Z}$ alone can define this rotation-symmetric set of bosonic codes.</p>
</li>
<li>
<p>The parameter $N$ quantifies the degree of discrete rotation symmetry for the code. Note that any state in the codespace that is $N$-fold rotation symmetric is invariant under rotation by $2\pi/N$, hence $\hat{R}_N=\hat{Z}^2_N$ is the <em>stabilizer</em>, i.e. it leaves the codeword invariant.</p>
</li>
<li>
<p>Because the codewords are $N$-fold rotation symmetry, any encoded state $|\psi_N\rangle$ has support only on every $N$th Fock state. This means that $|\psi_N\rangle = \sum_{k=0}^\infty c_{kN}|kN\rangle$. The degree of rotation symmetry thus quantifies the magnitude of a detectable shift in number and set a code <em>distance</em> in Fock space. Now if you think about it, in stablizer formalism, the codespace is a subspace of the Hilbert space $\mathcal{H}$ residing within are valid codewords. Similarly, the Fock space &lsquo;spanned&rsquo; by the $N$-fold symmetry states can only be reached if you start from a valid codeword, and then you do a multiple of $\pi/N$ rotation. If the environment did instead an arbitrary $U(\varphi)=\exp(i\theta\hat{n})$ rotation, i.e. a phase-shifting continuous operator, then it&rsquo;s an error.</p>
</li>
<li>
<p>A special subset of the bosonic rotation codes are <em>number-phase</em> codes, which are rotated superpositions of states with small phase uncertainty. Note that if the phase uncertainty is small, then the number uncertainty should be large. In deed, in the limit of vanishing phase uncertainty, the number-phase codes are analogous to ideal GKP codes, with number and phase are complementary variables in place of $x$ and $p$.</p>
</li>
<li>
<p>A critical question that must be asked repeatedly in quantum error corretion: is the redundancy worth it? In bosonic error-correting codes this question is equivalent to asking: whether the code performs better than a trivial encoding&ndash;a qubit encoded in Fock state $|0\rangle$ and $|1\rangle$ under the same set of noisy channels. The point where the error-corrected qubit performs <em>as well as</em> the trivial encoding is often referred to as the break-even point.</p>
</li>
</ol>
<h2 id="bosonic-rotation-codes">Bosonic rotation codes</h2>
<h3 id="preliminaries">Preliminaries</h3>
<p>Alright. That&rsquo;s enough with the introduction. Let us get into the real deal.</p>
<p>Basically we&rsquo;re trying to do single-qubit gate, so we only have to worry about single-mode bosonic codes atm. In experiments, the dominant noise processes are loss, gain, and dephasing. Loss means you lose one photon. Gain means you absorb one photon. And dephasing is basically a mixture of small, erroneous rotations in the phase-space (?).</p>
<p>We use discrete rotation symmetry to define a class of single-mode codes called bosonic rotation codes. The code has a discrete $N$-fold rotation symmetry if any state $|\psi\rangle$ in the codespace is a $+1$ eigenstate of the discrete rotation operator</p>
<p>\[
\hat{R}_N=\exp\left(i\dfrac{2\pi}{N}\hat{n}\right),
\]</p>
<p>where $\hat{n}=\hat{a}^\dagger\hat{a}$ is the Fock-space number operator. One can think of $\hat{R}_N$ as the identity operator <em>on</em> the codewords. One may even go further and say $\hat{R}_N$ is the stabilizer, however in other to detect the error we&rsquo;re not looking at the syndrome of $\hat{R}_N$.</p>
<p>We define an order-$N$ rotation code to be a code where the operator</p>
<p>\[
\hat{Z}_N \coloneqq \hat{R}_{2N} = \exp\left(i\dfrac{\pi}{N}\hat{n}\right)
\]</p>
<p>acts a logical $\bar{Z}$.</p>
<p>The logical codewords for any order-$N$ rotation code can be constructed from discrete rotated superpositions of a normalized <em>primitive</em> state $|\Theta\rangle$. In general, from the definition of $\bar{Z}$,</p>
<p>\[
\bar{Z}|0_L\rangle = |0_L\rangle,\newline
\bar{Z}|1_L\rangle = -|1_L\rangle
\]</p>
<p>the two orthogonal codewords must satisfy</p>
<p>\[\begin{align}
|0_L\rangle &amp;= \dfrac{1}{\mathcal{N}_0}\sum_{m=0}^{2N-1}e^{i\frac{m\pi}{N}\hat{n}}|\Theta\rangle,\newline
|1_L\rangle &amp;= \dfrac{1}{\mathcal{N}_1}\sum_{m=0}^{2N-1}(-1)^m e^{i\frac{m\pi}{N}\hat{n}}|\Theta\rangle,
\end{align}\]</p>
<p>Now, because the encoded logical states are characterized by two properties, first being the degree of $N$-fold rotational symmetry, and second being from which <em>primitive</em> state $\Theta$ the logical codeword are defined, hence we can change the subscript from $L\to N,\Theta$.</p>
<p>\[\begin{align}
|0_{N,\Theta}\rangle &amp;= \dfrac{1}{\sqrt{\mathcal{N}_0}}\sum_{m=0}^{2N-1}e^{i\frac{m\pi}{N}\hat{n}}|\Theta\rangle,\newline
|1_{N,\Theta}\rangle &amp;= \dfrac{1}{\sqrt{\mathcal{N}_1}}\sum_{m=0}^{2N-1}(-1)^m e^{i\frac{m\pi}{N}\hat{n}}|\Theta\rangle,
\end{align}\]</p>
<p>There is a technical constraint on the choice of $|\Theta\rangle$ which will be explored later.</p>
<p>When the rotated primitives $|\Theta\rangle$ are orthogonal, meaning that</p>
<p>\[
\begin{align}
\langle\Theta|(\hat{Z}_N)^m|\Theta\rangle =0,\forall 0 &lt; m &lt; 2N,
\end{align}
\]</p>
<p>then $\mathcal{N}_0=\mathcal{N}_1=2N$. Generally, however, they are not orthogonal, and the normalization constants are different. But, the codewords themselves are exactly orthogonal (of course, otherwise they are useless) for any valid $|\Theta\rangle$:</p>
<p>\[\begin{align}
\langle 0_{N,\Theta} | 1_{N,\Theta} \rangle = \dfrac{1}{\sqrt{\mathcal{N}_0\mathcal{N}_1}}\propto A\sum_{m=0}^{2N-1}(-1)^m = 0
\end{align}\]</p>
<p>because there is an even number of $(-1)^m$. Furthermore, any state in the codespace $|\psi_{N,\Theta}\rangle = a|0_{N,\Theta}\rangle + b|1_{N,\Theta}\rangle$ has $N$-fold rotation symmetry, since</p>
<p>\[
\begin{align}
\hat{R}_N|\psi_N\rangle = a\hat{R}_N|0_N\rangle + b\hat{R}_N|1_N\rangle=a|0_N\rangle + b|1_N\rangle \equiv |\psi_N\rangle,
\end{align}
\]</p>
<p>where we have suppress the $\Theta$-subscript.</p>
<p>Under this paradigm, we realize that rotation codes can have the same degree of rotation symmetry $N$. While a given primitive $|\Theta\rangle$ uniquely defines an order-$N$ rotation code, there are many possible primitives $|\Theta\rangle$ that give rise to the same code.</p>
<ol>
<li>
<p>The famous <code>cat code</code> has primitive being a coherent state of the harmonic oscillator $|\Theta_{\texttt{cat}}\rangle = |\alpha\rangle$.</p>
</li>
<li>
<p>Another example being the <code>0N</code> code, where logical codewords are $|0_\texttt{0N}\rangle=|0\rangle, |1_\texttt{0N}\rangle = |N\rangle$. The primitive state in this case <em>could</em> be, for example, $|\Theta_\texttt{0N}\rangle = (|0\rangle + |N\rangle)/\sqrt{2}$.</p>
</li>
</ol>
<h3 id="fock-space-structure">Fock-space structure</h3>
<blockquote>
<p>Discrete rotational symmetry enforces a spacing of the codewords in Fock space, which underpins the codes&rsquo; robustness to loss and gain errors.</p>
</blockquote>
<p>This statement basically means that we have a larger than 1 code distance. Consider the action of $\hat{Z}_N=\hat{R}_{2N}=\exp\left(i\frac{\pi}{N}\hat{n}\right)$ on an arbitrary state $|\psi\rangle = \sum_n a_n|n\rangle$,</p>
<p>\[
\begin{align}
\hat{Z}_N|\psi\rangle=\sum_n e^{i\pi n/N}a_n|n\rangle
\end{align}
\]</p>
<p>Clearly $|\psi\rangle$ is a $+1$ eigenstate of $\hat{Z}_N$ if and only if $a_n=0$ for all $n\neq 2kN$ (since, you know, $\exp(i 2k\pi)=1$). And $|\psi\rangle$ is a $-1$ eigenstate of $\hat{Z}_N$ if and only if $a_n=0$ for all $n\neq (2k+1)N$. This leads to the following general form for any $\pm 1$ eigenstates of $\hat{Z}_N$,</p>
<p>\[\begin{align}
|0_N\rangle &amp;= \sum_{k=0}^\infty f_{2kN} |2kN\rangle,\newline
|1_N\rangle &amp;= \sum_{k=0}^\infty f_{(2k+1)N} |(2k+1)N\rangle
\end{align}\]</p>
<p>To explicitly connect the two representations of rotation-symmetric codewords, one in the primitive states rep. and one in the Fock-basis, we use the relation for a Kronecker comb,</p>
<p>\[
\dfrac{1}{M}\sum_{m=0}^{M-1} \exp\left(i\dfrac{2\pi mn}{M}\right)=\sum_{k=0}^\infty \delta_{n, kM},\ n = 0, 1, 2,\dots
\]</p>
<p>to construct a projector onto the set of Fock states $|2kN+l\rangle$ for $k=0, 1, 2,\dots$. By definition, such a projector is</p>
<p>\[
\begin{align}
\Pi_{2N}^l \coloneqq \sum_{k=0}^\infty |2kN+l\rangle\langle 2kN + l|
\end{align}
\]</p>
<p>Using the Kronecker comb,</p>
<p>\[
\sum_{k=0}^\infty |2kN+l\rangle\langle 2kN + l| = \dfrac{1}{2N}\sum_{m=0}^{2N-1}\left(e^{-i\frac{\pi l}{N}}\hat{Z}_N\right)^m
\]</p>
<p>The factors $e^{i\pi l/N}$ with $l\in\{0, 1, \dots, 2N-1\}$ are the complex $2N$th roots of unity. Acting the projector on a primitive state $|\Theta\rangle = \sum_n c_n|n\rangle$ with at least one non-zero $c_{2kN+l}$</p>
<p>\[
\Pi_{2N}^l |\Theta\rangle = \sum_{k=0}^\infty c_{2kN+l}|2kN +l\rangle
\]</p>
<p>will produce an unnormalized eigenstate of the operator $\hat{Z}_N$ with eigenvalue $e^{i\pi l/N}$.</p>
<p>It is now straightforward to see that the two representation are equivalent, since we can write</p>
<p>\[
\begin{align}
|0_N\rangle = \dfrac{\hat{\Pi}^0_{2N}|\Theta\rangle}{\sqrt{\mathcal{N}_0^*}},\newline
|1_N\rangle = \dfrac{\hat{\Pi}^N_{2N}|\Theta\rangle}{\sqrt{\mathcal{N}_1^*}},\newline
\end{align}
\]</p>
<p>For the codewords to be well-defined it is now clear that the <em>primitive</em> must have support on at least one of the $|2kN\rangle$ Fock states and one on the $|(2k+1)N\rangle$ Fock states. Because they have support of different Fock states, they are by definition orthogonal.</p>
<p>The dual-basis codewords, $|\pm_N\rangle$ are constructed as usual via plus and minus equal superposition of the encoded $|0_N\rangle$ and $|1_N\rangle$. In the Fock space representations, they are</p>
<p>\[
\begin{align}
|+_N\rangle &amp;= \dfrac{1}{\sqrt{2}}\sum_{k=0}^\infty f_{kN}|kN\rangle,\newline
|-_N\rangle &amp;= \dfrac{1}{\sqrt{2}}\sum_{k=0}^\infty (-1)^k f_{kN}|kN\rangle
\end{align}
\]</p>
<p>Because we&rsquo;re having both support from even multiple of $N$ and odd multiple of $N$, both $|\pm_N\rangle$ have support on the full set of $|kN\rangle$ Fock states. It&rsquo;s interesting to note that, as one compares $|0_N\rangle$ and $|+_N\rangle$, one realizes any logical $|0_N\rangle$ state is also a logical $|+_{2N}\rangle$ for a code with twice the rotation symmetry (i.e. we going from $N$-fold symmetry to $2N$-fold symmetry), which is not necessarily the <em>same</em> code. In other words, for a given codeword $|0_{N,\Theta}\rangle$ defined by a primitive $|\Theta\rangle$, we have that</p>
<p>\[
\begin{align}
|0_{N,\Theta}\rangle = |+_{2N,\Theta&rsquo;}\rangle
\end{align}
\]</p>
<p>for some primitive $|\Theta&rsquo;\rangle$. Whenever the codeword normalization constant equal to each other, the primitive states must be the same.</p>
<p>While we have a nice picture of how to do $Z$ operation within our error-correcting schemes, we don&rsquo;t have an equally simple picture of $X$ operation. We&rsquo;ll try to do $\bar{X}$ later.</p>
<p>Now, a useful quantity for comparing codes is the average excitation number of the code,</p>
<p>\[
\begin{align}
\bar{n}_{\texttt{code}} &amp;= \dfrac{1}{2}\text{tr}\left[\hat{\Pi}_{\texttt{code}}\hat{n}\right]\newline
&amp;=\dfrac{1}{2}\left(\langle 0_N|\hat{n} |0_N\rangle + \langle 1_N|\hat{n}|1_N\rangle\right)
\end{align}
\]</p>
<p>By construction the average excitation number is the same for each of the dual-basis codewords, and should be $\bar{n}_{\texttt{code}}=\langle \pm_N|\hat{n}|\pm_N\rangle$. Since the rotation operator commutes with number operator, rotations do not increase the excitation number. The computational-basis codewords have different average excitation number due to different phases in the superpositions, but it remains bounded.</p>
<h3 id="the-phase-grids-and-the-fock-grids">The phase grids and the Fock grids</h3>
<p>With a given primitive $|\Theta\rangle$, the order of rotation symmetry $N$ parameterizes a code both in phase space and in Fock space. It is therefore natural to think of two different concepts of code distance. Here, we have <em>number distance</em> $d_n\coloneqq N$ and <em>rotational distance</em> $d_\theta \coloneqq \pi/N$. The number rotation and phase-space rotation play a dual rule: Codes of increasing $N$ are further separated in Fock space but are more closely separated in terms of rotations. For an order-$N$ rotation code, we refer to the set of angles $\{m d_\theta\}$ for $m=0, 1, \dots, 2N-1$ as the phase grid and the set of Fock states $\{|kN\rangle\}$ for $k=0,1,\dots$ as the Fock grid. These are in analogy to the position- and momentum-space grids on which GKP codes are defined. The phase grid and Fock grid broadly characterize the types of error to which the code is intrinsically robust. For example, loss and gain errors, representing by $\sim\hat{a}^k$ or $\sim(\hat{a}^\dagger)^k$ are detectable as long as $k&lt;d_n = N$. Dephasing errors, representing by $e^{i\theta\hat{n}}$, should be detectable as long as $\theta&lt; d_\theta$.</p>
<h3 id="distinguishing-the-code-words">Distinguishing the code words</h3>
<p>A natural way of thinking is to use number and phase measurements. In the computational basis, one would think about measuring the average number of excitation, since we&rsquo;re in the Fock state basis anyway. However, one could think of phase measurement once they&rsquo;re in the dual basis</p>
<ol>
<li>
<p>Number measurement: For an order-$N$ code, a number measurement returns an outcome $kN$ for integer $k$. If $k$ is even, then the logical state is $0$, odd otherwise. In the presence of errors, such a measurement can still correctly identify the damaged codewords. For instance, assuming that the probability of loss and gain events are equally likely, then a straightforward way to decode is to: measure $n$, and round to the nearest $kN$. If $k$ is even, then it was &ldquo;0&rdquo;, and odd otherwise.</p>
</li>
<li>
<p>Phase measurement: An approach to distinguishing $|\pm_{N,\Theta}\rangle$ with a certain robustness relies on phase estimation. In noiseless scheme, the task can be formulated as follows: Given the code word $|+_{N,\Theta}\rangle$ for a rotation code, determine $\theta$ in $e^{i\theta\hat{n}}|+_{N,\Theta}\rangle$. If $\theta\mod 2\pi/N = 0$, the state is $|+_{N,\Theta}\rangle$, while if $\theta\mod 2\pi/N = \pi/N$, the state is $|-_{N,\Theta}\rangle$. Note that by design, $|-_N\rangle=e^{i(\pi/N)\hat{n}}|+_N\rangle$.</p>
</li>
</ol>
<h2 id="number-phase-codes">Number-phase codes</h2>
<p>We have to sacrifice an embedded phase uncertainty $\Delta_N(\theta)$ in out measurement scheme above. This phase uncertainty is minimized when the distribution of Fock-grid coefficients is completely flat, i.e. $|f_{kN}|=|f_{(k+1)N}|$ for all $k$. In such cases, $|\langle e^{iN \phi}\rangle|=1$ and the phase uncertainty vanishes (if you think about it, we have all amplitude coefficients being equal to each other, meaning that we don&rsquo;t have <em>any</em> information regardings the number of excitation). The only problem with this scheme is that such state is not normalizable, making the scheme purely theoretical. However, we theorize that there exists a certain limit of Fock-grid coefficients such that the phase uncertainty is sufficiently small. As it turns out, this limit exists.</p>
<h3 id="ideal-number-phase-codes">Ideal number-phase codes</h3>
<p>In analogy with ideal GKP codes defined in terms of superpositions of position (or momentum) eigenstates, we define a familty of order-$N$ rotation codes as</p>
<p>\[
\begin{align}
|0_{N,\texttt{phase}}\rangle&amp;\coloneqq\sum_{m=0}^{2N-1}|\phi\rangle,\newline
|1_{N,\texttt{phase}}\rangle&amp;\coloneqq\sum_{m=0}^{2N-1}(-1)^m|\phi\rangle
\end{align}
\]</p>
<p>where the general $\phi\rangle$ state are the superpositions of Pegg-Barnett phase states</p>
<p>\[
\begin{align}
|\phi\rangle \coloneqq \dfrac{1}{\sqrt{2\pi}}\sum_{n=0}^\infty e^{in\phi}|n\rangle
\end{align}
\]</p>
<p>For our ideal number-phase codes, this phase state is chosen such that $\phi=m\pi/N$.</p>
<p>\[
\begin{align}
|\phi_{N,\texttt{phase}}\rangle \coloneqq \dfrac{1}{\sqrt{2\pi}}\sum_{n=0}^\infty e^{i(m\pi/N)n}|n\rangle
\end{align}
\]</p>
<p>One may perform summation over $m$ to see that the aboved-defined encoded states are supported by $2kN$ Fock states for logical &lsquo;0&rsquo; and $(2k+1)N$ Fock states for logical &lsquo;1&rsquo;. Indeed,</p>
<p>\[
\begin{align}
|0_{N,\texttt{phase}}\rangle &amp;= \sum_{m=0}^{2N-1} \dfrac{1}{\sqrt{2\pi}}\sum_{n=0}^\infty e^{i(m\pi/N)n}|n\rangle \newline
&amp;=\dfrac{1}{\sqrt{2\pi}}\sum_{n=0}^\infty\sum_{m=0}^{2N-1}e^{i\pi mn/N}|n\rangle
\end{align}
\]</p>
<p>Note that</p>
<p>\[
\begin{align}
\dfrac{1}{2N}\sum_{m=0}^{2N-1}\exp\left(i\dfrac{i\pi m n}{2N}\right)=\sum_{k=0}^\infty\delta_{n,2kN}
\end{align}
\]</p>
<p>Then
\[
\begin{align}
|0_{N,\texttt{phase}}\rangle &amp;= \dfrac{1}{\sqrt{2\pi}}\sum_{n=0}^\infty\sum_{m=0}^{2N-1}e^{i\pi mn/N}|n\rangle\newline
&amp;\propto \sum_{n=0}^\infty\sum_{k=0}^{\infty}\delta_{n/2,kN}|n\rangle=\sum_{k=0}^\infty |2kN\rangle
\end{align}
\]</p>
<p>Similarly for the encoded <code>1</code>, where there is a surplus $(-1)^m$ in the front, then</p>
<p>\[
\begin{align}
|1_N\rangle \propto \sum_{k=0}^\infty |(2k+1)N\rangle
\end{align}
\]</p>
<p>Any state in the codespace spanned by $\{|0_{N,\texttt{phase}}\rangle, |1_{N,\texttt{phase}}\rangle\}$ is a $+1$ eigenstate of $\hat{R}_N$. The codewords are also $+1$ eigenstates of a number translation operator such that</p>
<p>\[
\hat{\sum}_N \coloneqq \sum_{n=0}^\infty |n\rangle \langle n + 2N|,
\]</p>
<p>We can define an $\hat{X}_N$ gate from this generalized operator,</p>
<p>\[
\begin{align}
\hat{X}_N \coloneqq \hat{\sum}_{N/2} = \sum_{n=0}^\infty |n\rangle \langle n+N|
\end{align}
\]</p>
<p>Note that this $\hat{X}_N \coloneqq \hat{\sum}_{N/2}$ operator commute with the rotation operator $\hat{R}_N$ (an encoded logical operator commute with the stabilizer) and anticommute with $\hat{Z}_N$, so it&rsquo;s good.</p>
<h3 id="approximate-number-phase-codes">Approximate number-phase codes</h3>
<p>Ideal number-phase codes as defined above are unphysical, because they require an infinite excitation number and are not normalizable.</p>
<p>However, one can see that for any rotation code with positive, real Fock-grid coefficients $\{f_{kN}\}$, we have $\langle \pm_{N,\Theta}|\hat{X}_N|\pm_{N,\theta}\rangle=\pm \langle e^{iN\theta}\rangle$.</p>
<p>This $\langle e^{iN\theta}\rangle$ thing is called the mean modular phase,</p>
<p>\[
\langle e^{iN\theta}\rangle = \int_0^{2\pi} e^{iN\theta}\mu(\theta)d\theta = \dfrac{1}{2}\sum_{k=0}^\infty |f_{kN}f_{(k+1)N}|,
\]</p>
<p>Remember that plus and minus are eigenstates of the $X$ operator, hence for the $\hat{X}_{N}$ gate we <em>should</em> have the mean modular phase approaches unity. This is true if and only if $\Delta_N(\theta)\to 0$. In the limit of vanishing phase uncertainty, we obtain a family of codes whose stabilizer are $\hat{\sum}_N$ and for which $\hat{X}_N$ acts as a logical $\bar{X}$.</p>
<p>An interesting property of number-phase codes arises from the fact that as the phase uncertainty vanishes, two normalization constants are equal. It immediately follows that the dual-basis codewords also become equal-weight superpositions of the primitive state. Hence, a stronger number-phase duality emerges: the dual-basis codewords $|\pm_N\rangle$ are separated from each other by exactly $d_\theta=\pi/N$ in terms of phase-space rotations, but have support on the exact same set of Fock states. Conversely, the computational-basis codewords are separated from each other by $d_n=N$ in Fock space, but supported on the same set of phases $\{m\pi/N\}$.</p>
<p>Next, we briefly examine in which regime notable bosonic rotation codes become number-phase code.</p>
<ol>
<li>
<p>First being the codes constructed using normalized Pegg-Barnett phase states as introduced above. As the parameter that sets their truncation in Fock space becomes large $s\to\infty$, Pegg-Barnett codes approach ideal number-phase codes.</p>
</li>
<li>
<p>Cat codes and binomial codes approach the phase vanishing regime in the limit of large $\alpha$ and large truncation $K$ respectively.</p>
</li>
</ol>
<p>Informally speaking, we refer to any family of rotation codes that satisfies $\Delta_N(\theta)\to 0$ in an approachable limit as number-phase code.</p>
<h3 id="symmetry-as-a-resource-quantum-computing-with-number-phase-codes">Symmetry as a resource: quantum computing with number-phase codes</h3>
<p>Here we introduce a universal quantum computing scheme based on three basic ingredients: preparation of codewords in the state $|+_N\rangle$, a small number of unitary gates, and (destructive) measurement in the logical $\hat{X}$ basis.</p>
<blockquote>
<p>For unitary gates, fault tolerant means the gates should not amplitfy errors too badly. For measurement scheme, fault tolerant means the codewords $|\pm_N\rangle$ should be distinguishable in the presence of small errors.</p>
</blockquote>
<p>Here, we&rsquo;ll see that given a supply of encoded basis state $|+_N\rangle$, rotation symmetry and number-translation symmetry imply the ability to execute any gate in the logical Clifford group.</p>
<h3 id="universal-operations-for-number-phase-codes">Universal operations for number-phase codes</h3>
<p>The quantum computing scheme introduced in the following is based on the universal set</p>
<p>\[
\{\bar{S}, \bar{C}_Z\} \cup \{\mathcal{P}_{|+_N\rangle}, \mathcal{P}_{|T_N\rangle}, \mathcal{M}_X\}
\]</p>
<p>where</p>
<ol>
<li>$\bar{S}$ is an encoded version of the phase gate, $\hat{S}=\text{diag}(1,i)$;</li>
<li>$\bar{C}_Z$ is an encoded $\hat{C}_Z=\text{diag}(1,1,1,-1)$;</li>
<li>$\mathcal{P}$ stands for the preparation of an encoded state;</li>
<li>$\mathcal{M}_X$ stands for measurement in the logical $|\pm_N\rangle$ basis.</li>
</ol>
<p>The state $|T_N\rangle \propto |0_N\rangle + e^{i\pi/4}|1_N\rangle$ is used for gate teleportation of the non-Clifford $\hat{T}$.</p>
<h4 id="unitary-gates">Unitary gates</h4>
<p>We have already shown that logical $\bar{Z}$ for an order-$N$ rotation code can be implemented through a simple rotation $\hat{Z}_N=e^{i\pi\hat{n}/N}$. The next gate in our set is the following two-mode gate that implements a controlled-rotation between an order-$N$ and an order-$M$ rotation code,</p>
<p>\[
\text{CROT}_{NM} \coloneqq e^{i(\pi/NM)\hat{n}\otimes\hat{n}}
\]</p>
<p>To understand its action of the codespace, we recognize that</p>
<p>\[
\text{CROT}_{NM}|i_N\rangle \otimes |j_M\rangle = (-1)^{ij}|i_N\rangle \otimes |j_M\rangle,
\]</p>
<p>for $i,j=0,1$. Thus, the $\text{CROT}$ gate acts as a $\bar{C}_Z$ gate on the codespace of <em>any</em> two rotation codes.</p>
<p>This is a cross-Kerr interaction. We can also have self-Kerr interaction, by noticing that $\bar{S}=\hat{S}_N\coloneqq e^{i(\pi/2N^2)\hat{n}^2}$. The action of this phase gate can be further understood by considering the Fock states,</p>
<p>\[
\begin{align}
\hat{S}_N|2kN\rangle = e^{(i\pi/2)4k^2}|2kN\rangle = |2kN\rangle,\newline
\hat{S}_N|(2k+1)N\rangle =e^{(i\pi/2)(4k^2+4k+1)}|(2k+1)N\rangle = i|(2k+1)N\rangle
\end{align}
\]</p>
<h4 id="teleported-gates">Teleported gates</h4>
<p>The $\text{CROT}$ gate and logical $\mathcal{M}_X$ measurements, together with appropriately prepared ancillae, allow us to complete a universal set of operation with a gate-teleported logical Hadamard $\bar{H}$ and $\bar{T}$ gate.</p>
<p>An ancilla prepared in $|+_M\rangle$ allows execution of the Hadamard gate, using a teleportation circuit. Because this scheme is based only on Clifford gates and magic-state injection, rather than correcting the conditional Pauli $\bar{X}$, the simplest solution is to keep track of it in the Pauli frame. Alternatively, the process can be repeated until the desired outcome is achieved. This is indeterministic quantum computation.</p>
<p>The set $\{\bar{C}_Z, \bar{H}, \bar{S}\}$ generates the Clifford group. To achieve universality, we teleport the gate $\hat{T}$ by consuming an ancilla prepared in $|T_M\rangle = (|0_M\rangle+e^{i\pi/4}|1_M\rangle)/\sqrt{2}$.</p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>The most embarrasing thing I ever did as an undegrad physics was to write $({a})^\dagger = {a}$. In my defense, it looks kind of tempting.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>

			</div>

			<div class="tags">
				
					
						<ul class="flat">
							
							<li class="tag-li"><a href="/tags/quant-ph">quant-ph</a></li>
							
							<li class="tag-li"><a href="/tags/quantum-error-correction">quantum-error-correction</a></li>
							
						</ul>
					
				
			</div>

			
			<div class="back">
				<a href="https://github.com/ngdnhtien/ngdnhtien-content/blob/master/content/posts/bosonic-qubits.md" title="github"><i data-feather="github"></i> Edit this on GitHub</a>
			</div>
			
			
			<div class="back">
				<a href="https://ngdnhtien.github.io/"><span aria-hidden="true">← Back</span></a>
			</div>
			

			<div class="back">
				
					
					Next time, we'll talk about <i>"10 ways how quantum computing will solve climate change."</i>
					
				
			</div></div>
		
	</div>
	
	<div class="footer wrapper">
	<nav class="nav">
		<div>2023  © Nguyen Dinh Tien </div>
		
	</nav>
</div><script>feather.replace()</script>
</body>
</html>
